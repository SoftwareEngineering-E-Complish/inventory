from webbrowser import get
from sqlalchemy.orm import Session
from sqlalchemy import select, func, Select, Sequence
from app.models.property import Property
from app.schemas.property_query import PropertyQuery, ResultOrder
from typing import Tuple
from app.utils.db_connector import get_session

class PropertyService:
    dbSession: Session = get_session()

    def set_session(self, session: Session):
        self.dbSession = session
        return self

    def insert_property(self, property: Property)-> Property:
        #set key to null even if it is provided so it can be autogenerated
        property.propertyId = None #type: ignore
        property.views = 0 #type: ignore
        property.searches = 0 #type: ignore
        self.dbSession.add(property)
        self.dbSession.commit()
        self.dbSession.refresh(property)
        self.dbSession.close()
        return property
    
    def update_property(self, property_id: int, property: Property)-> Property:
        statement = select(Property).where(Property.propertyId == property_id)
        property_db = self.dbSession.execute(statement).scalars().first()
        if not property_db:
            raise Exception("Property not found")
        
        for key, value in vars(property).items():
            if key == "propertyId" or key== "owner" or key.startswith("_"):
                continue
            if key == "searches" or key == "views":
                continue
            if value is not None:
                print(key, value)
                setattr(property_db, key, value)

        self.dbSession.commit()
        self.dbSession.refresh(property_db)
        self.dbSession.close()
        return property_db

    def fetch_property(self, property_id: int) -> Property:
        statement = select(Property).where(Property.propertyId == property_id)
        property = self.dbSession.execute(statement).scalars().first()
        property.views += 1 #type: ignore
        self.dbSession.commit()
        self.dbSession.refresh(property)
        self.dbSession.close()
        return property

    def fetch_all(self):
        statement = select(Property)
        properties = self.dbSession.execute(statement).scalars().all()

        for property in properties:
            property.searches += 1 #type: ignore
        
        self.dbSession.commit()

        for property in properties:
            self.dbSession.refresh(property)
        
        self.dbSession.close()
        return properties

    def fetch_by_user(self, userId: str):
        statement = select(Property).where(Property.owner == userId)
        properties = self.dbSession.execute(statement).scalars().all()
        self.dbSession.close()
        return properties

    def fetch_by_attributes(self, query: PropertyQuery)-> Tuple[Sequence[Property], int]:
        count_statement = set_attributes(query, select(func.count()).select_from(Property))
        count = self.dbSession.execute(count_statement).scalar()
        query_statement = set_attributes(query, select(Property))
        query_statement = set_pagination(query, query_statement)
        query_statement = set_order(query, query_statement)
        properties = self.dbSession.execute(query_statement).scalars().all()

        for property in properties:
            property.searches += 1
        self.dbSession.commit()
        for property in properties:
            self.dbSession.refresh(property)

        self.dbSession.close()
        return properties, count #type: ignore

def set_attributes(query: PropertyQuery,  statement: Select)-> Select:
    if query.price_min:
        statement = statement.where(Property.price >= query.price_min)
    if query.price_max:
        statement = statement.where(Property.price <= query.price_max)
    if query.bedrooms_min:
        statement = statement.where(Property.bedrooms >= query.bedrooms_min)
    if query.bedrooms_max:
        statement = statement.where(Property.bedrooms <= query.bedrooms_max)
    if query.bathroom_min:
        statement = statement.where(Property.bathrooms >= query.bathroom_min)
    if query.bathroom_max:
        statement = statement.where(Property.bathrooms <= query.bathroom_max)
    if query.square_meters_min:
        statement = statement.where(Property.square_meters >= query.square_meters_min)
    if query.square_meters_max:
        statement = statement.where(Property.square_meters <= query.square_meters_max)
    if query.year_built_from:
        statement = statement.where(Property.year_built >= query.year_built_from)
    if query.year_built_to:
        statement = statement.where(Property.year_built <= query.year_built_to)
    if query.property_type:
        statement = statement.where(Property.property_type == query.property_type.value)
    if query.location:
        statement = statement.where(Property.location == query.location.value)
    return statement

def set_pagination(query: PropertyQuery, statement: Select)-> Select:
    if query.limit:
        statement = statement.limit(query.limit)
    if query.offset:
        statement = statement.offset(query.offset)
    return statement

def set_order(query: PropertyQuery, statement: Select) -> Select:
    if query.order:
        if query.order == ResultOrder.PRICE_ASC:
            statement = statement.order_by(Property.price)
        if query.order == ResultOrder.PRICE_DESC:
            statement = statement.order_by(Property.price.desc())
        if query.order == ResultOrder.BEDROOMS_ASC:
            statement = statement.order_by(Property.bedrooms)
        if query.order == ResultOrder.BEDROOMS_DESC:
            statement = statement.order_by(Property.bedrooms.desc())
        if query.order == ResultOrder.BATHROOMS_ASC:
            statement = statement.order_by(Property.bathrooms)
        if query.order == ResultOrder.BATHROOMS_DESC:
            statement = statement.order_by(Property.bathrooms.desc())
        if query.order == ResultOrder.SQUARE_METERS_ASC:
            statement = statement.order_by(Property.square_meters)
        if query.order == ResultOrder.SQUARE_METERS_DESC:
            statement = statement.order_by(Property.square_meters.desc())
        if query.order == ResultOrder.YEAR_BUILT_ASC:
            statement = statement.order_by(Property.year_built)
        if query.order == ResultOrder.YEAR_BUILT_DESC:
            statement = statement.order_by(Property.year_built.desc())
    return statement